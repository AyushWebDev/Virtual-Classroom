"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAssignmentFeeds = exports.deleteAssignment = exports.updateAssignment = exports.createAssignment = void 0;
const knex_1 = __importDefault(require("knex"));
const knexfile_1 = __importDefault(require("../../knexfile"));
const { v4: uuidv4 } = require("uuid");
const assignment_1 = require("../model/assignment");
const auth_1 = require("../model/auth");
const query = (0, knex_1.default)(knexfile_1.default); // configuring knex and getting query builder
const createAssignment = (ctx, req) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    //generating uuid for assign_id , it could be generated by default
    //but in that case one more GET call would be required to insert
    //into student and assignment mapping
    const assignmentId = uuidv4();
    // creating assignments
    const { description, userId, deadline } = req;
    const publishedAt = (_a = req.publishedAt) !== null && _a !== void 0 ? _a : Date.now();
    const status = publishedAt > Date.now() ? assignment_1.ASSIGNMENT_STATUS.SCHEDULED : assignment_1.ASSIGNMENT_STATUS.ONGOING;
    const assigment = yield query("assignments").insert({
        assignment_id: assignmentId,
        description: description,
        tutor_id: userId,
        published_at: new Date(publishedAt),
        deadline: new Date(deadline),
        status,
    });
    console.log(assigment);
    const studentList = req.studentList;
    //assigning assignments to all the students in student_list
    studentList.map((studentId) => __awaiter(void 0, void 0, void 0, function* () {
        yield query("submissions").insert({
            student_id: studentId,
            assignment_id: assignmentId,
            status: assignment_1.SUBMISSION_STATUS.PENDING,
        });
    }));
    return {
        status: 201,
        body: "Created",
    };
});
exports.createAssignment = createAssignment;
const updateAssignment = (ctx, reqBody, assignmentId) => __awaiter(void 0, void 0, void 0, function* () {
    let updateFields = {};
    if (reqBody.description)
        updateFields.description = reqBody.description;
    if (reqBody.deadline)
        updateFields.deadline = new Date(reqBody.deadline);
    //query for updating assignments field
    const updatedAssignment = yield query("assignments")
        .where("assignment_id", assignmentId)
        .update(updateFields);
    console.log(updatedAssignment);
    //creating response
    return {
        status: 200,
        body: "Updated",
    };
});
exports.updateAssignment = updateAssignment;
const deleteAssignment = (ctx, assignmentId) => __awaiter(void 0, void 0, void 0, function* () {
    //deleting entities from submissions table
    yield query("submissions").where("assignment_id", assignmentId).del();
    //deleting entity from assignments tables
    yield query("assignments").where("assignment_id", assignmentId).del();
    return {
        status: 204,
    };
});
exports.deleteAssignment = deleteAssignment;
const getTutorAssignments = (ctx, tutorId) => __awaiter(void 0, void 0, void 0, function* () {
    const publishedAt = ctx.query.publishedAt;
    return publishedAt
        ? yield query("assignments").select("*").where("tutor_id", tutorId).andWhere("status", publishedAt)
        : yield query("assignments").select("*").where("tutor_id", tutorId);
});
const getStudentsAssignments = (ctx, studentId) => __awaiter(void 0, void 0, void 0, function* () {
    const publishedAt = ctx.query.publishedAt;
    const status = ctx.query.status;
    return query("assignments")
        .join("submissions", "assignments.assignment_id", "=", "submissions.assignment_id")
        .select("assignments.*")
        .where('submissions.student_id', studentId)
        .andWhere('assignments.status', publishedAt)
        .andWhere('submissions.status', status);
});
const getAssignmentFeeds = (ctx) => __awaiter(void 0, void 0, void 0, function* () {
    const { userId } = ctx.state.user;
    const user = yield query("users")
        .select("user_role")
        .where("user_id", userId)
        .first();
    if (user.user_role === auth_1.ROLE.TUTOR) {
        const assignments = yield getTutorAssignments(ctx, userId);
        return {
            status: 200,
            body: assignments,
        };
    }
    const assignments = yield getStudentsAssignments(ctx, userId);
    return {
        status: 200,
        body: assignments,
    };
});
exports.getAssignmentFeeds = getAssignmentFeeds;
//# sourceMappingURL=assignment.js.map